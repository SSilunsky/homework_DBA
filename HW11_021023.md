# Домашняя работа №11 (к занятию от 02.10.23)
[Виды индексов. Работа с индексами и оптимизация запросов]

- [x] Использую ранее созданный инстанс виртуальной машины "postgres2" с дефолтными параметрами в YC (ОС:Ubuntu 22.04, HDD 10Gb, RAM 4Gb);
- [x] Добавлен ssh ключ в metadata ВМ yc_key.pub;
- [x] Развернут кластер БД PostgreSQL 15;

`silunsky@postgres:~$ pg_lsclusters`

`Ver Cluster Port Status Owner    Data directory              Log file`

`15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log`

- [x] В БД **silunsky_db** создадим таблицу **otus1**. Создадим индекс на таблицу **otus1**.

`silunsky_db=# create table otus1 as`

`select generate_series as id`

`    , generate_series::text || (random() * 10)::text as col2`

    , (array['Yes', 'No', 'Maybe'])[floor(random() * 3 + 1)] as is_okay
`from generate_series(1, 50000);`

`create index idx_otus1_id on otus1(id);`

SELECT 50000

CREATE INDEX

выполним проверку с помощью команды 

`silunsky_db=# \di+`

List of relations

| Schema |         Name          | Type  |  Owner   |      Table       | Persistence | Access method |  Size   | 
|--------|-----------------------|-------|----------|------------------|-------------|---------------|---------|
| public | idx_otus1_id          | index | postgres | otus1            | permanent   | btree         | 1112 kB | 

`silunsky_db=# select pg_size_pretty(pg_table_size('otus1'));`

| pg_size_pretty |
|----------------|
| 3104 kB        |
(1 row)

`silunsky_db=# select pg_size_pretty(pg_table_size('idx_otus1_id'));`

| pg_size_pretty |
|----------------|
|3104 kB         |
(1 row)

---

- [x] Прислать текстом результат команды explain, в которой используется индекс **idx_otus1_id**

для этого выполним следующую команду:

`silunsky_db=# explain`

`select id from otus1 where id = 1;`

|QUERY PLAN                                                                      |
|------------------------------------------------------------------------------- |
| Index Only Scan using idx_otus1_id on otus1  (cost=0.29..1.41 rows=1 width=4)  |
|   Index Cond: (id = 1)                                                         |
(2 rows)

---

- [x] Реализовать индекс для полнотекстового поиска

Создадим уникальный индекс для полнотекстового поиска

silunsky_db=# create index idx_some_text on otus1(is_okay);
CREATE INDEX


ℹ️ Более предпочтительными для текстового поиска являются индексы GIN. Будучи инвертированными индексами, они содержат записи для всех отдельных слов (лексем) с компактным списком мест их вхождений. При поиске нескольких слов можно найти первое, а затем воспользоваться индексом и исключить строки, в которых дополнительные слова отсутствуют. Индексы GIN хранят только слова (лексемы) из значений tsvector, и теряют информацию об их весах. Таким образом для выполнения запроса с весами потребуется перепроверить строки в таблице. Индекс GiST допускает неточности, то есть он допускает ложные попадания и поэтому их нужно исключать дополнительно, сверяя результат с фактическими данными таблицы. (PostgreSQL делает это автоматически.) Индексы GiST являются неточными, так как все документы в них представляются сигнатурой фиксированной длины. Длина сигнатуры в байтах определяется значением необязательного целочисленного параметра siglen. По умолчанию (когда параметр siglen отсутствует) равно 124 байтам, а максимальная длина сигнатуры равна 2024 байтам. Сигнатура формируется в результате представления присутствия каждого слова как одного бита в строке из n-бит, а затем логического объединения этих битовых строк. Если двум словам будет соответствовать одна битовая позиция, попадание оказывается ложным. Если для всех слов оказались установлены соответствующие биты (в случае фактического или ложного попадания), для проверки правильности предположения о совпадении слов необходимо прочитать строку таблицы. При увеличении размера сигнатуры поиск работает точнее (сканируется меньшая область в индексе и меньше страниц кучи), но сам индекс становится больше.Индексы ускоряют работу БД, а по мере ее разрастания их эффективность становится очевиднее. При этом важно помнить о том, что индексам необходимо место для хранения. При добавлении данных в БД сначала обновляется исходная таблица, а затем все ее индексы. В связи с этим, лучше использовать индексы для БД в хранилищах данных, получающих плановые обновления, т.е. в часы наименьшей нагрузки, а не для производственных, которые обновляются постоянно. Это объясняется тем, что при постоянных обновлениях БД индексы обновляться не будут, а следовательно станут бесполезны. 

---

- [x] Реализуем индекс на часть таблицы и индекс на поле с функцией:

- Создадим индекс **idx_otus1_id_100** на часть таблицы **otus1**:

`silunsky_db=# create index idx_otus1_id_100 on otus1(id) where id < 100;`

CREATE INDEX

`silunsky_db=# explain`

`select * from otus1 where id < 50;`

| QUERY PLAN                                                                 |
|----------------------------------------------------------------------------|
| Index Scan using idx_otusu_id on otus1  (cost=0.29..3.38 rows=51 width=31) |
|   Index Cond: (id < 50)                                                    |
(2 rows)

ℹ️ Частичный индекс. Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть очень полезны. Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования распространённых значений. Так как при поиске распространённого значения (такого, которое содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хранить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции изменения данных в таблице, так как индекс будет обновляться не всегда.

- Создадим индекс на поле с функцией:

`silunsky_db=# create index idx_otus1_id_is_okay on otus1(lower(is_okay));`

CREATE INDEX

`silunsky_db=# explain`

`select * from otus1 where lower(is_okay) = 'True';`

| QUERY PLAN                                                                          |
|-------------------------------------------------------------------------------------|
| Bitmap Heap Scan on otus1  (cost=3.33..201.70 rows=250 width=31)                    |
|   Recheck Cond: (lower(is_okay) = 'True'::text)                                     | 
|   ->  Bitmap Index Scan on idx_otus1_id_is_okay  (cost=0.00..3.27 rows=250 width=0) |
|        Index Cond: (lower(is_okay) = 'True'::text)                                  |
(4 rows)

ℹ️ Поддержка индексируемых выражений обходится довольно дорого, так как эти выражения должны вычисляться при каждом добавлении строки и при каждом изменении без оптимизации HOT. Однако при поиске по индексу индексируемое выражение не вычисляется повторно, так как его результат уже сохранён в индексе. Таким образом, индексы по выражениям(функциям) могут быть полезны, когда скорость извлечения данных гораздо важнее скорости добавления и изменения.

---

- [x] Создадим индекс на несколько полей:

silunsky_db=# create index idx_otus1_id_and_is_okay on otus1(id, is_okay);
CREATE INDEX

Сравним планы запросов:

`silunsky_db=# explain`

`select * from otus1 where id = 1 and is_okay = 'True';`

|QUERY PLAN                                                                             |
|---------------------------------------------------------------------------------------|
| Index Scan using idx_otus1_id_and_is_okay on otus1  (cost=0.29..1.89 rows=1 width=31) |
|   Index Cond: ((id = 1) AND (is_okay = 'True'::text))                                 |
(2 rows)

`silunsky_db=# explain`

`select * from otus1 where id = 1;`

| QUERY PLAN                                                                    |                                
|-------------------------------------------------------------------------------|
| Index Scan using idx_otus1_id_100 on otus1  (cost=0.14..2.36 rows=1 width=31) |
|   Index Cond: (id = 1)                                                        |
(2 rows)

`silunsky_db=# explain`

`select * from otus1 where is_okay = 'True';`

|QUERY PLAN                                                                               |                                        
|-----------------------------------------------------------------------------------------|
| Index Scan using idx_otus1_id_and_is_okay on otus1  (cost=0.29..548.50 rows=1 width=31) |
|   Index Cond: (is_okay = 'True'::text)                                                  |
(2 rows)

`silunsky_db=# explain`

`select * from otus1 order by id desc , is_okay desc;`

`SET enable_incremental_sort = on;`

| QUERY PLAN                                                                                            |
|-------------------------------------------------------------------------------------------------------|
| Index Scan Backward using idx_otus1_id_and_is_okay on otus1  (cost=0.29..1322.83 rows=50002 width=31) |
(1 row)

SET

ℹ️ В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Возможность построения индекса по нескольким ключевым столбцам не зависит от возможности добавления в индекс неключевых столбцов (INCLUDE). Число столбцов в индексе ограничивается 32, включая столбцы INCLUDE. Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.










