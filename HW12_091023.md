# Домашняя работа №12 (к занятию от 09.10.23)
[Секционирование таблицы]

- [x] Использую ранее созданный инстанс виртуальной машины "postgres2" с дефолтными параметрами в YC (ОС:Ubuntu 22.04, HDD 10Gb, RAM 4Gb);
- [x] Добавлен ssh ключ в metadata ВМ yc_key.pub;
- [x] Развернут кластер БД PostgreSQL 15;

`silunsky@postgres:~$ pg_lsclusters`

`Ver Cluster Port Status Owner    Data directory              Log file`

`15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log`

- [x] Используем демонстрационную базу Перелеты.
⚠️ Демонстрационная база данных взята с edu.postgrespro.ru: demo-big.zip (232 МБ) — данные по полётам за год (размер БД около 2,5 ГБ)
Файлы содержат SQL-скрипт, создающий базу данных demo и наполняющий её данными (фактически, это резервная копия, созданная утилитой pg_dump). Владельцем базы данных demo станет пользователь СУБД, выполнявший скрипт. 
В кластере `15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log`
создана БД **demo**

`demo=# \dt`
List of relations
|  Schema  |      Name       | Type  |  Owner   |
|----------|-----------------|-------|----------|
| bookings | aircrafts_data  | table | postgres |
| bookings | airports_data   | table | postgres |
| bookings | boarding_passes | table | postgres |
| bookings | bookings        | table | postgres |
| bookings | flights         | table | postgres |
| bookings | seats           | table | postgres |
| bookings | ticket_flights  | table | postgres |
| bookings | tickets         | table | postgres |
(8 rows)

`demo=# select pg_size_pretty(pg_table_size('flights'));`

| pg_size_pretty | 
|----------------|
| 21 MB          |
(1 row)

`demo=# select pg_size_pretty(pg_table_size('tickets'));`

| pg_size_pretty  | 
|---------------- |
| 386 MB          |
(1 row)

`demo=# select pg_size_pretty(pg_table_size('bookings'));`

| pg_size_pretty| 
|---------------|
| 105 MB        |
(1 row)

- [x] Прежде всего ознакомимся со структурой таблиц **bookings** и **tickets** базы двнных **demo**

`demo=# \d bookings`

Table "bookings.bookings"
|    Column    |           Type           | Collation | Nullable | Default |
|--------------|--------------------------|-----------|----------|---------|
| book_ref     | character(6)             |           | not null |         |
| book_date    | timestamp with time zone |           | not null |         |
| total_amount | numeric(10,2)            |           | not null |         |
|Indexes:     "bookings_pkey" PRIMARY KEY, btree (book_ref)|
|Referenced by:     TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)|

`demo=# \d tickets`

Table "bookings.tickets"
|     Column     |         Type          | Collation | Nullable | Default 
|----------------+-----------------------+-----------+----------+---------
| ticket_no      | character(13)         |           | not null | 
| book_ref       | character(6)          |           | not null | 
| passenger_id   | character varying(20) |           | not null | 
| passenger_name | text                  |           | not null | 
| contact_data   | jsonb                 |           |          | 
|Indexes:     "tickets_pkey" PRIMARY KEY, btree (ticket_no)|
|Foreign-key constraints:     "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)|
|Referenced by:     TABLE "ticket_flights" CONSTRAINT "ticket_flights_ticket_no_fkey" FOREIGN KEY (ticket_no) REFERENCES tickets(ticket_no)|

- [x] Теперь, понимая структуру сделаем таблицу **bookings** секционированной по диапазону дат. Для этого выполним следующие действия:

Создадим таблицу **bookings_range**

`demo=# CREATE TABLE bookings_range (`
 
     `  book_ref     character(6),`

     `  book_date    timestamptz,`
     
     `  total_amount numeric(10,2)`

 `  ) PARTITION BY RANGE(book_date);`
 
CREATE TABLE

`demo=# \d bookings_range `

Partitioned table "bookings.bookings_range"
|    Column    |           Type           | Collation | Nullable | Default |
|--------------|--------------------------|-----------|----------|---------|
| book_ref     | character(6)             |           |          |         |
| book_date    | timestamp with time zone |           |          |         |
| total_amount | numeric(10,2)            |           |          |         |
|Partition key: RANGE (book_date)|
|Number of partitions: 0|

- Создадим секции(партиции) на каждый месяц:

`demo=# CREATE TABLE bookings_range_201706 PARTITION OF bookings_range `

      ` FOR VALUES FROM ('2017-06-01'::timestamptz) TO ('2017-07-01'::timestamptz);`

CREATE TABLE

`demo=# CREATE TABLE bookings_range_201707 PARTITION OF bookings_range `

       `FOR VALUES FROM ('2017-07-01'::timestamptz) TO ('2017-08-01'::timestamptz);`

CREATE TABLE

`demo=# CREATE TABLE bookings_range_201606 PARTITION OF bookings_range `

      ` FOR VALUES FROM ('2016-06-01'::timestamptz) TO ('2016-07-01'::timestamptz);`
      
CREATE TABLE

`demo=# CREATE TABLE bookings_range_201607 PARTITION OF bookings_range `

     `  FOR VALUES FROM ('2016-07-01'::timestamptz) TO ('2016-08-01'::timestamptz);`

CREATE TABLE

`demo=# CREATE TABLE bookings_range_201608 PARTITION OF bookings_range `

       `FOR VALUES FROM ('2016-08-01'::timestamptz) TO ('2016-09-01'::timestamptz);`
       
CREATE TABLE

`demo=# CREATE TABLE bookings_range_201609 PARTITION OF bookings_range `

      ` FOR VALUES FROM ('2016-09-01'::timestamptz) TO ('2016-10-01'::timestamptz);`

CREATE TABLE

`demo=# CREATE TABLE bookings_range_201610 PARTITION OF bookings_range `

     `  FOR VALUES FROM ('2016-10-01'::timestamptz) TO ('2016-11-01'::timestamptz);`
     
CREATE TABLE

- Для указания границ секции можно использовать не только константы, но и выражения, например вызов функции. Значение выражения вычисляется в момент создания секции
 и сохраняется в системном каталоге:

`demo=# CREATE TABLE bookings_range_201708 PARTITION OF bookings_range `

       `FOR VALUES FROM (to_timestamp('01.08.2017','DD.MM.YYYY'))` 
       
                   ` TO (to_timestamp('01.09.2017','DD.MM.YYYY'));`
CREATE TABLE

- Теперь, посмотрим на структуру таблицы **bookings_range** после партиционирования:

`demo=# \d+ bookings_range`

Partitioned table "bookings.bookings_range"
|    Column    |           Type           | Collation | Nullable | Default | Storage  | Compression | Stats target | Description |
|--------------|--------------------------|-----------|----------|---------|----------|-------------|--------------|-------------|
| book_ref     | character(6)             |           |          |         | extended |             |              |             | 
| book_date    | timestamp with time zone |           |          |         | plain    |             |              |             |
| total_amount | numeric(10,2)            |           |          |         | main     |             |              |             |

Partition key: RANGE (book_date)

Partitions: bookings_range_201606 FOR VALUES FROM ('2016-06-01 00:00:00+00') TO ('2016-07-01 00:00:00+00'),

bookings_range_201607 FOR VALUES FROM ('2016-07-01 00:00:00+00') TO ('2016-08-01 00:00:00+00'),
            
bookings_range_201608 FOR VALUES FROM ('2016-08-01 00:00:00+00') TO ('2016-09-01 00:00:00+00'),

bookings_range_201609 FOR VALUES FROM ('2016-09-01 00:00:00+00') TO ('2016-10-01 00:00:00+00'),

bookings_range_201610 FOR VALUES FROM ('2016-10-01 00:00:00+00') TO ('2016-11-01 00:00:00+00'),

bookings_range_201706 FOR VALUES FROM ('2017-06-01 00:00:00+00') TO ('2017-07-01 00:00:00+00'),

bookings_range_201707 FOR VALUES FROM ('2017-07-01 00:00:00+00') TO ('2017-08-01 00:00:00+00'),

bookings_range_201708 FOR VALUES FROM ('2017-08-01 00:00:00+00') TO ('2017-09-01 00:00:00+00')







